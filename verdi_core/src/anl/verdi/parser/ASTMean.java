/* Generated By:JJTree: Do not edit this line. ASTMean.java */

package anl.verdi.parser;

import ucar.ma2.Array;
import ucar.ma2.Index;
import anl.verdi.formula.IllegalFormulaException;
import anl.verdi.util.FormulaArray;

public class ASTMean extends AggregateFuncNode {

//	private double val;
	//private int count;

  public ASTMean(int id) {
    super(id);
  }

  public ASTMean(Parser p, int id) {
    super(p, id);
  }


	/**
	 * Evaluates this Node.
	 * 
	 * NOTE: Changed this function from domain-based mean to mean over time-steps (within a layer)
	 * for each individual cell in the domain. Q.H. 12/06/2010
	 *
	 * @param frame
	 * @return the result of the evaluation.
	 */
	@Override
	public FormulaArray evaluate(Frame frame) throws IllegalFormulaException {
		Array array = jjtGetChild(0).evaluate(frame).getArray();
		Array meanA = calcMean(array);

		return new FormulaArray(meanA, false);
	}
	
	private Array calcMean(Array array) {
		Array meanA = array.copy();
		int rank = array.getRank();

		int[] shape = array.getShape();
		
		if (rank != 4) return array;
		
		if (rank == 4 && shape[0] == 1) return array;
		
		if (rank == 4) {
			Index index = array.getIndex();

			for (int i = 0; i < shape[2]; i++) {
				for (int j = 0; j < shape[3]; j++) {
					for (int k = 0; k < shape[1]; k++) {
						double sum = 0;
						
						for (int t = 0; t < shape[0]; t++) {
							index.set(t, k, i, j);
							double val = array.getDouble(index);
							sum += val;
						}
						
						for (int t = 0; t < shape[0]; t++) {
							index.set(t, k, i, j);
							meanA.setDouble(index, sum / shape[0]);
						}
					}
				}
			}
		}
		
		return meanA;
	}
}
